<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Gallame Level Editor - V5 (Interactive)</title>
    <style>
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #222; }
        
        /* Zone de texte (Gauche) */
        #editor-container {
            width: 30%;
            background: #2d2d2d;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #555;
            z-index: 10;
        }
        .toolbar {
            padding: 10px;
            background: #333;
            color: white;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border-bottom: 1px solid #555;
        }
        .toolbar-row { display: flex; justify-content: space-between; align-items: center; }
        
        textarea {
            flex-grow: 1;
            background: #1e1e1e;
            color: #a9b7c6;
            border: none;
            padding: 15px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            resize: none;
            outline: none;
            white-space: pre;
        }

        /* Zone de visualisation (Droite) */
        #preview-container {
            width: 70%;
            background: #555; 
            overflow: auto;
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
        }
        
        canvas {
            display: block;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            margin: 0;
            flex-shrink: 0;
            cursor: crosshair; /* Curseur pr√©cis pour le clic */
        }

        /* Info bulle curseur */
        #cursor-info {
            position: fixed;
            bottom: 20px;
            right: 40px;
            background: rgba(0, 0, 0, 0.9);
            color: #0f0;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: monospace;
            pointer-events: none;
            border: 1px solid #0f0;
            font-size: 14px;
            z-index: 1000;
        }

        input[type=range] { vertical-align: middle; }
    </style>
</head>
<body>

    <div id="editor-container">
        <div class="toolbar">
            <div class="toolbar-row">
                <h2 style="margin:0; font-size:16px;">Level Editor V5</h2>
                <span style="color:#aaa">Y=0 est le SOL</span>
            </div>
            <div class="toolbar-row">
                <label for="zoomSlider">Zoom: <span id="zoomValue">100%</span></label>
                <input type="range" id="zoomSlider" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 120px;">
            </div>
            <div class="toolbar-row" style="color:#ffd700; font-style: italic;">
                <span>üí° Clique sur un bloc pour modifier sa ligne</span>
            </div>
        </div>
        <textarea id="inputData" spellcheck="false">
# Niveau Interactif
name, Test Highlight
start, 50, 50
sky, #87CEEB

# Sol immense
bloc, 0, 0, 3000, 20

# Tour (Clique sur moi !)
bloc, 200, 100, 100, 20
bloc, 200, 300, 100, 20
bloc, 200, 500, 100, 20
bloc, 200, 700, 100, 20
bloc, 200, 900, 100, 20
bloc, 200, 1100, 100, 20

# Exemple Color√©
bloc_colored, 600, 200, 200, 50, #ff00ff
npc, 650, 250, 40, 60, null, Je suis rose !

fin, 1500, 1500, 50, 50
        </textarea>
    </div>

    <div id="preview-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="cursor-info">X: 0 | Y_SOL: 0</div>

<script>
    const textarea = document.getElementById('inputData');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cursorInfo = document.getElementById('cursor-info');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueLabel = document.getElementById('zoomValue');
    const previewContainer = document.getElementById('preview-container');

    // Config Visuelle
    const GROUND_DISPLAY_HEIGHT = 200; 
    const SKY_MARGIN_TOP = 400;

    // √âtat Global
    let currentZoom = 1.0;
    let worldZeroY = 0;
    let worldOffsetX = 0;
    let activeLineIndex = -1; // Index de la ligne o√π se trouve le curseur texte
    let parsedObjects = []; // On stocke les objets pour le clic

    // --- 1. D√âTECTION DU CURSEUR TEXTE ---
    function updateActiveLine() {
        // Trouve l'index de la ligne actuelle en fonction de la position du curseur
        const cursorPos = textarea.selectionStart;
        const textUpToCursor = textarea.value.substr(0, cursorPos);
        activeLineIndex = textUpToCursor.split('\n').length - 1;
        parseAndRender(); // Redessine pour afficher le highlight
    }

    // --- 2. FONCTION DE PARSING ET RENDU ---
    function parseAndRender() {
        const text = textarea.value;
        const lines = text.split('\n');
        
        let config = { sky: "#81e1ff", ground: "#99edc3", maxX: 1000, maxY: 800, minX: 0 };
        parsedObjects = []; // Reset global storage

        // PARSING
        lines.forEach((line, index) => {
            const trimLine = line.trim();
            if (!trimLine || trimLine.startsWith('#')) return;

            let parts = trimLine.split(',').map(s => s.trim());
            let type = parts[0].toLowerCase();
            let data = parts.slice(1);

            if (type.startsWith("mob_")) { data.unshift(type.substring(4)); type = "mob"; }

            function checkBounds(x, y, w, h) {
                const r = x + (w||0); 
                const t = y + (h||0);
                const l = x;
                if (r > config.maxX) config.maxX = r + 500;
                if (l < config.minX) config.minX = l - 500;
                if (t > config.maxY) config.maxY = t;
            }

            let o = null;
            if (type.includes('bloc')) {
                o = { type: 'block', subtype: type, x: +data[0], y: +data[1], w: +data[2], h: +data[3], extra: data[4]||'NORMAL' };
            } else if (type === 'start') {
                o = { type: 'start', x: +data[0], y: +data[1], w: 20, h: 20 };
            } else if (type === 'fin') {
                o = { type: 'fin', x: +data[0], y: +data[1], w: +data[2], h: +data[3] };
            } else if (type === 'mob') {
                o = { type: 'mob', mobType: data[0], x: +data[1], y: +data[2], w: 30, h: 40 };
            } else if (type === 'npc') {
                o = { type: 'npc', x: +data[0], y: +data[1], w: +data[2], h: +data[3], msg: parts.slice(6).join(',') };
            } else if (type === 'door' || type === 'porte') {
                o = { type: 'door', x: +data[0], y: +data[1], w: +data[2], h: +data[3], target: data[4] };
            } else if (type === 'image' || type === 'background') {
                o = { type: 'bg_image', path: data[0], x: +data[1], y: +data[2], w: +data[3], h: +data[4] };
            } else if (type === 'sky') config.sky = data[0];
            else if (type === 'ground') config.ground = data[0];

            if (o) { 
                o.lineIndex = index; // ‚≠ê Sauvegarde le num√©ro de ligne pour le lien bi-directionnel
                checkBounds(o.x, o.y, o.w, o.h); 
                parsedObjects.push(o); 
            }
        });

        // CALCUL DIMENSIONS
        const LEFT_PADDING = 500;
        worldOffsetX = Math.abs(Math.min(config.minX, 0)) + LEFT_PADDING;
        
        const worldHeight = config.maxY + SKY_MARGIN_TOP + GROUND_DISPLAY_HEIGHT;
        const worldWidth = config.maxX - config.minX + LEFT_PADDING + 500;
        worldZeroY = worldHeight - GROUND_DISPLAY_HEIGHT;

        canvas.width = worldWidth * currentZoom;
        canvas.height = worldHeight * currentZoom;

        // RENDU
        ctx.save();
        ctx.scale(currentZoom, currentZoom);
        ctx.translate(worldOffsetX, 0);

        // Fond
        ctx.fillStyle = config.sky;
        ctx.fillRect(-worldOffsetX, 0, worldWidth, worldZeroY);
        ctx.fillStyle = config.ground;
        ctx.fillRect(-worldOffsetX, worldZeroY, worldWidth, GROUND_DISPLAY_HEIGHT);
        
        ctx.beginPath(); 
        ctx.moveTo(-worldOffsetX, worldZeroY);
        ctx.lineTo(worldWidth - worldOffsetX, worldZeroY);
        ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = 2; ctx.stroke();

        const getY = (y, h) => worldZeroY - y - (h||0);

        // Dessin des objets
        parsedObjects.forEach(obj => {
            let cy = getY(obj.y, obj.h);
            obj.renderY = cy; // Stockage pour le hit-test du clic

            // --- GESTION DU HIGHLIGHT (SURBRILLANCE) ---
            // Si l'objet correspond √† la ligne active dans l'√©diteur
            const isSelected = (obj.lineIndex === activeLineIndex);
            
            if (isSelected) {
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#FFD700"; // Gold glow
            }

            if (obj.type === 'block') {
                ctx.fillStyle = '#555';
                if (obj.subtype.includes('colored')) ctx.fillStyle = obj.extra;
                else if (String(obj.extra).toUpperCase() === 'DEADLY') ctx.fillStyle = '#d32f2f';
                else if (String(obj.extra).toUpperCase() === 'ICE') ctx.fillStyle = '#b3e5fc';
                
                ctx.fillRect(obj.x, cy, obj.w, obj.h);
                ctx.strokeStyle = isSelected ? '#FFD700' : '#000'; // Bordure jaune si s√©lectionn√©
                ctx.lineWidth = isSelected ? 3 : 1;
                ctx.strokeRect(obj.x, cy, obj.w, obj.h);
                if(obj.subtype.includes('textured')) { ctx.fillStyle='black'; ctx.fillText("IMG", obj.x+2, cy+12); }
            }
            else if (obj.type === 'start') {
                ctx.fillStyle = '#00e676'; ctx.beginPath(); ctx.arc(obj.x, cy+15, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.fillText("START", obj.x-15, cy-5);
                if(isSelected) { ctx.strokeStyle='#FFD700'; ctx.lineWidth=3; ctx.stroke(); }
            }
            else if (obj.type === 'fin') {
                ctx.fillStyle = 'gold'; ctx.fillRect(obj.x, cy, obj.w, obj.h);
                ctx.strokeStyle = isSelected ? '#fff' : 'black'; ctx.strokeRect(obj.x, cy, obj.w, obj.h);
                ctx.fillStyle = 'black'; ctx.fillText("FIN", obj.x+5, cy+15);
            }
            else if (obj.type === 'mob') {
                ctx.fillStyle = '#f44336'; ctx.fillRect(obj.x, cy, obj.w, obj.h);
                if(isSelected) { ctx.strokeStyle='#FFD700'; ctx.lineWidth=3; ctx.strokeRect(obj.x, cy, obj.w, obj.h); }
            }
            else if (obj.type === 'npc') {
                ctx.fillStyle = '#ce93d8'; ctx.fillRect(obj.x, cy, obj.w, obj.h);
                if(isSelected) { ctx.strokeStyle='#FFD700'; ctx.lineWidth=3; ctx.strokeRect(obj.x, cy, obj.w, obj.h); }
                if(obj.msg) {
                    ctx.fillStyle = 'white'; ctx.strokeStyle='black';
                    let w = ctx.measureText(obj.msg).width + 10;
                    ctx.fillRect(obj.x, cy-25, w, 20); ctx.strokeRect(obj.x, cy-25, w, 20);
                    ctx.fillStyle='black'; ctx.fillText(obj.msg, obj.x+5, cy-12);
                }
            }
            else if (obj.type === 'door') {
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(obj.x, cy, obj.w, obj.h);
                ctx.fillStyle = 'white'; ctx.fillText(obj.target||"?", obj.x, cy-5);
                if(isSelected) { ctx.strokeStyle='#FFD700'; ctx.lineWidth=3; ctx.strokeRect(obj.x, cy, obj.w, obj.h); }
            }
            
            if (isSelected) ctx.restore(); // Retire le glow pour les autres objets
        });

        ctx.restore();
    }

    // --- 3. CLIC SUR LE CANVAS POUR S√âLECTIONNER LE TEXTE ---
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;

        // Conversion pixel -> monde
        const worldX = (pixelX / currentZoom) - worldOffsetX;
        const worldY_pixel = pixelY / currentZoom;
        const solY = worldZeroY - worldY_pixel; // Y par rapport au sol

        // Chercher l'objet cliqu√© (simple box collision)
        // On it√®re √† l'envers pour s√©lectionner celui dessin√© par dessus en premier
        for (let i = parsedObjects.length - 1; i >= 0; i--) {
            const obj = parsedObjects[i];
            
            // On v√©rifie si le clic est dans la bo√Æte de l'objet
            // Note: obj.renderY est la position Y haut de l'objet dans le canvas (avant zoom)
            // On recalcule le Y monde "visuel" ou on utilise la BBox simple
            
            // Approche simple : Est-ce que worldX est dans [x, x+w] et worldY (sol) dans [y, y+h] ?
            // Attention : Y augmente vers le haut dans notre logique monde
            if (worldX >= obj.x && worldX <= obj.x + (obj.w || 20) &&
                solY >= obj.y && solY <= obj.y + (obj.h || 20)) {
                
                // OBJET TROUV√â ! -> S√©lectionner la ligne dans le textarea
                selectLine(obj.lineIndex);
                break;
            }
        }
    });

    function selectLine(lineIndex) {
        const lines = textarea.value.split('\n');
        
        // Calcul de la position de d√©but et fin de la ligne
        let startPos = 0;
        for (let i = 0; i < lineIndex; i++) {
            startPos += lines[i].length + 1; // +1 pour le \n
        }
        let endPos = startPos + lines[lineIndex].length;

        textarea.focus();
        textarea.setSelectionRange(startPos, endPos);
        
        // Ajuster le scroll du textarea pour voir la ligne
        const lineHeight = 18; // Approx (12px font * 1.5 line-height)
        const linesInView = textarea.clientHeight / lineHeight;
        textarea.scrollTop = (lineIndex - linesInView / 2) * lineHeight;

        // Mettre √† jour la vue
        activeLineIndex = lineIndex;
        parseAndRender();
    }

    // EVENT LISTENERS
    zoomSlider.addEventListener('input', (e) => {
        currentZoom = parseFloat(e.target.value);
        zoomValueLabel.innerText = Math.round(currentZoom * 100) + "%";
        parseAndRender();
    });

    // Mises √† jour quand on tape ou bouge le curseur
    textarea.addEventListener('input', () => { updateActiveLine(); });
    textarea.addEventListener('keyup', () => { updateActiveLine(); });
    textarea.addEventListener('click', () => { updateActiveLine(); });

    // TRACKER SOURIS
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const pixelX = e.clientX - rect.left;
        const pixelY = e.clientY - rect.top;
        const worldX = (pixelX / currentZoom) - worldOffsetX;
        const worldY_pixel = pixelY / currentZoom;
        const solY = worldZeroY - worldY_pixel;
        cursorInfo.innerText = `X: ${Math.round(worldX)} | Y_SOL: ${Math.round(solY)}`;
        if (solY < 0) cursorInfo.style.color = 'red'; else cursorInfo.style.color = '#0f0';
    });

    // Init
    parseAndRender();
    setTimeout(() => { previewContainer.scrollTop = previewContainer.scrollHeight; }, 100);

</script>

</body>
</html>